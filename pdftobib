#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This module reads all .pdf files in its directory and produces a .bib file
(default: articles.bib), containing BibTeX extries for all pdfs possible.
"""

from __future__ import print_function, unicode_literals
import argparse
import glob
import os
import re
import subprocess
import sys
try:
    import urllib
    import urllib.request as req
    from urllib.parse import quote
except ImportError:
    from urllib import quote
    import urllib2 as req
    import codecs
    reload(sys)  # Hack to put setdefaultencoding back in after python startup
    sys.setdefaultencoding('utf-8')  # Output utf-8 to teminal


class BibtexFile:

    def __init__(self, path=''):
        self.path = path
        self.entries = []
        self.fill_entries()

    def __contains__(self, item):
        #return item in self.entries
        return repr(item) in self.entries

    def append(self, item):
        pass

    def fill_entries(self):
        pass

    def write_to_file(self):
        #self.entries.sort()
        pass


class Article:

    def __init__(self, path=None):
        self.path = path
        self.bibcode = None
        self.bibtex = None
        self.url = None
        self.identifier = None
        self.identifier_type = None
        if path is not None:
            self.extract_info()
            self.create_url()
            self.get_bibtex()

    def __repr__(self):
        return self.bibcode

    def extract_info(self):
        """
        Extract identifying information from a text file converted from a pdf

        Parameters:
        -----------
        txt_file: string
            The path to a text file to extract information from

        Returns:
        --------
        tuple: 2 elements, (identifier type, value)
            identifier type can be {'doi', arxiv', 'abs'}
        """
        if sys.version_info[0] < 3:
            pdf_txt = codecs.open(self.path, 'r', 'utf-8')
        else:
            pdf_txt = open(self.path, 'r')
        # First search for DOI and ABS/arXiv bibcode by regex
        bibcode = None
        for line in pdf_txt:
            line = line.lower()
            try:
                self.identifier_type = 'doi'
                self.identifier = re.search(
                                    r'[0-9]{2}'       # 2 digits
                                    r'\.'             # .
                                    r'[0-9]{4}'       # 4 digits
                                    r'/'              # /
                                    r'.*?'            # min num of anything
                                    r'(?=[\ (\n)])',  # end at space/newline
                                    line            ).group()
                return
            except AttributeError:
                pass
            try:
                #arxiv bibcode
                bibcode = line.index('arxiv')
                if line[bibcode + 5] == ')':
                    continue
                bibcode = line.split()[0][6:]
                if bibcode[-2] == 'v':
                    bibcode = bibcode[:-2]
                self.identifier_type = 'arxiv'
                self.identifier = bibcode
                return
            except ValueError:
                pass
            try:
                #abs bibcode
                self.identifier_type = 'abs'
                self.identifier = re.match(
                                    r'[0-9]{4}'     # year
                                    r'[a-z&]{2,6}'  # journal
                                    r'.*'           # some number of .'s
                                    r'[0-9]{1,4}'   # volume
                                    r'[a-z]?'       # can have 'L' etc
                                    r'.*'           # some number of .'s
                                    r'[0-9]{1,4}'   # start page
                                    r'[a-z]'        # author initial
                                    r'\n',          # new line
                                    line          ).group()[:-1]
                return
            except AttributeError:
                continue
        pdf_txt.seek(0)
        # Not found, so have to construct an ABS bibcode
        # List so that order is preserved (for apjs)
        journals = [['a&a', 'aap'],
                    ['the astronomical journal', 'aj'],
                    ['the astrophysical journal', 'apj'],
                    ['the astrophysical journal supplement', 'apjs'],
                    ['annu. rev. astron. astrophys.', 'ara&a'],
                    ['annu. rev. astro. astrophys.', 'ara&a'],
                    ['mon. not. r. astron. soc.', 'mnras'],
                   ]
        for line in pdf_txt:
            line = line.lower()
            # Look for a single line with a journal name and year
            if (any(j[0] in line for j in journals) and
                    re.search('[0-9]{4}', line)):
                # Journal
                journal = [j[1] for j in journals if j[0] in line][-1]
                # Volume and first page
                vol_pages_re = (r'[0-9]{1,4}'     # volume
                                r'[:,\s]{1,4}'    # volume-pages separator
                                r'l?'             # if a Letter
                                r'[0-9]{1,4}'     # start page
                                r'([-––è]|\sy)?'  # start-end page separator
                                r'l?'             # if a letter
                                r'([0-9]{1,4})?'  # end page (may not exist)
                               )
                vol_pages = re.search(vol_pages_re, line).group()
                volume = re.search(r'[0-9]{1,4}[:,\s]', vol_pages).group()[:-1]
                pages = re.sub(volume, '', vol_pages)
                qualifier = '.'
                if re.search('l', pages):
                    qualifier = 'l'
                page = re.search(r'[0-9]{1,4}', pages).group()

                # Year
                year_line = re.sub([j[1] for j in journals if j[0] in line][0],
                                   '', line)
                year_line = re.sub(vol_pages, '', year_line)
                year = re.search('[0-9]{4}', year_line).group()

                # Construct bibcode from parts derived above
                self.identifier_type = 'abs'
                self.identifier = ''.join([year, journal,
                                           '.' * (9 - len(journal)
                                                    - len(volume) ),
                                           volume, qualifier,
                                           '.' * (4 - len(page)), page])
                return

    def create_url(self, ads_mirror):
        """
        Get a URL of a BibTeX entry for the paper

        Parameters:
        -----------
        identifier: 2 element tuple, (identifier type, value)
            identifier type can be {'doi', arxiv', 'abs'}

        Returns:
        --------
        string
            A URL that can be resolved to find a BibTeX entry
        """
        if self.identifier_type is 'doi':
            self.url = ''.join(['http://', ads_mirror,
                                '/cgi-bin/nph-bib_query?'
                                '&doi={0}'.format(self.identifier),
                                '&data_type=BIBTEX&db_key=AST&nocookieset=1'])
        elif self.identifier_type is 'arxiv':
            # Two different formats for arxiv_ids (change at 2007)
            # Paper may also have been submitted to another branch e.g. hep
            arxiv_ads = None
            try:  # old
                year = int(self.identifier[self.identifier.index('/') + 1:
                                           self.identifier.index('/') + 3 ])
                arxiv_ads = ''.join(['astro.ph',
                    '.' * (6 - len(str(int(self.identifier[11:])))),
                                     str(int(self.identifier[11:])) ])
            except ValueError:  # new
                year = int(self.identifier[:2])
                arxiv_ads = 'arxiv' + self.identifier
            if year > 13:
                year = str(year + 1900)
            else:
                year = str(year + 2000)
            arxiv_ads = year + arxiv_ads
            if self.identifier == 'hep':
               arxiv_ads = self.identifier
            self.url = ''.join(['http://', ads_mirror,
                                '/cgi-bin/nph-bib_query?',
                                '&bibcode={0}'.format(arxiv_ads),
                                '&data_type=BIBTEX&db_key=AST&nocookieset=1'])
        else:  # ABS code
            self.url = ''.join(['http://', ads_mirror,
                                '/cgi-bin/nph-bib_query?',
                                '&bibcode={0}'.format(quote(self.identifier)),
                                '&data_type=BIBTEX&db_key=AST&nocookieset=1' ])
        return


    def get_bibtex(self, ads_mirror):
        full_bibtex_page = req.urlopen(self.url).readlines()

        bib_list = []
        for line in full_bibtex_page[5:-1]:
            bib_list.append(line.decode('iso-8859-1'))

        bib_dict = parse_bibtex(bib_list)
        print(bib_dict)

        self.bibtex = {}
        # Need to parse bibtex entry and make necessary changes
        for line in range(len(bib)):
            line_list = bib[line].lower().split()
            if line_list[:9] == '@article{':
                self.bibcode = line_list[9:-1]
                self.bibtex['bibcode'] = self.bibcode
            if line_list[0] == 'author':
                self.bibtex['author'] = []
                bib[line] = bib[line][10:]
                for author_line in range(line, len(bib)):
                    if (bib[author_line] in ['\n', '}\n'] or
                            bib[author_line].lower().split()[1] is '='):
                        break
                    for author in author_line.lower().split('and'):
                        if author == '\n':
                            continue
                        count = 0
                        name = ''
                        initials = ''
                        initial_list = []
                        for character in author:
                            if character == '{':
                                count += 1
                            elif character == '}':
                                count -= 1
                            if count > 0:
                                name += character
                            else:
                                initials += character
                        for element in initials.split('.'):
                            for character in element:
                                if character.isalpha():
                                    initial_list.append(character)
                        self.authors.append(latex_to_text(name[1:]),
                                           tuple(initial_list)     )
                self.author = self.authors[0][0]
            elif line_list[0] == 'year':
                self.bibtex['year'] = line_list[2][:-1]
            elif line_list[0] == 'journal':
                self.bibtex['journal']= format_journal(' '.join(line_list[2:]))
            elif line_list[0] == 'adsurl':
                self.url = os.path.split(line_list[2][1:-2])[-1]
                self.url = self.url.replace(ads_mirror, 'adsabs.harvard.edu')
                self.bibtex['url'] = self.url
            elif line_list[0] == 'doi':
                self.doi = line_list[2][1:-2]
                self.bibtex['doi'] = self.doi
            elif line_list[0] == 'title':
                self.title = latex_to_text(bib[line][14:-4])


def parse_bibtex_entry(bib_list):

    bib_dict = {}
    last_key = None
    for line in bib_list:
        line_list = line.split()
        try:
            if line_list[1] == '=':
                bib_dict[line_list[0]] = ' '.join(line_list[2:])
                last_key = line_list[0]
            else:
                bib_dict[last_key] += line
    # All bibtex keys are now dictionary keys
    # Need to remove { " , from beginning/end of bib_dict values
    for key in bib_dict:
        if bib_dict[key][-1] == ',':
            bib_dict[key] = bib_dict[key][:-1]
        while:
            if bib_dict[key][0] in ['{', '"']
                    and bib_dict[key][-1] in ['{', '"']:
                bib_dict[key] = bib_dict[key][1:-1]
            else:
                break
    return bib_dict


def exists_in_bib(pdf, bib_file):
    """
    Determine if a paper has already been added to the bib_file

    Parameters:
    -----------
    pdf: string
        The current pdf being processed
    bib_file: string
        The name of the .bib file the script writes to

    Returns:
    --------
    boolean
        True if paper exists in bib_file, False otherwise
    """
    try:
        pdf = pdf[(pdf.index('/') + 1):]
    except ValueError:
        pass
    try:
        bibcode = pdf.split()[2]
        #name_end = pdf.index(' - ')
        #ref_name = ''.join((pdf[:name_end] +
        #                    pdf[(name_end + 3):][:(pdf[(name_end + 3):] \
        #                                           .index(' - '))]
        #                   ).lower().split())
        exists = False
        with open(bib_file, 'r') as bib:  # make sure bib_file gets closed
            for line in bib:
                if line.find(bibcode) != -1:
                    exists = True
                    break
        if exists:
            return True
    except (ValueError, IOError):
        pass
    return False


def format_journal(journal):
    """
    Convert ADS journal codes into names suitable for use in references

    Parameters
    ----------
    journal: string
        An ADS BibTeX journal code eg '\apj'

    Returns
    -------
    string
        The formatted version of a journal name eg 'ApJ'
    """
    journal_name = journal[1: -2]
    journals = {
        r'\aap': r'A\&A',
        r'\aaps': r'A\&AS',
        r'\aj': 'AJ',
        r'\apj': 'ApJ',
        r'\apjl': 'ApJL',
        r'\apjs': 'ApJS',
        r'\araa': r'ARA\&A',
        'ArXiv e-prints': 'arXiv',
        r'\mnras': 'MNRAS',
        r'\nat': 'Nature',
        r'\pasp': 'PASP',
        r'\physrep': 'Phys. Rep.',
    }
    text_name = journal_name
    if journal_name in journals:
        text_name = journals[journal_name]
    return '{' + text_name + '},'


def latex_to_text(latex):
    """
    Convert a string with latex characters to a standard character set

    Parameters
    ----------
    latex : string
        A string containing possible LaTeX encodings eg 'H$_{2}$O'

    Returns
    -------
    string
        A string converted to a standard format eg H20
    """
    # Set out a list of conversions (list preserves order - needed for \ etc)
    conversions = [[[r'\ss'], 'ß'],
                   [[r'\times'], '✕'],
                   [[r'\alpha'], 'α'],
                   [[r'\beta'], 'β'],
                   [[r'\mu'], 'μ'],
                   [[r'\gt'], '>'],
                   [[r'\lt'], '<'],
                   [[r'\~{n}', r'\~n'], 'ñ'],
                   [[r'\~', r'\tilde'], '~'],
                   [[r'\ndash'], '-'],
                   [[r'\&'], '&'],
                   [[r'\"', r"\'", "'", '`',
                     '{', '}','$', '/', '^', '_', '\\'], '']
                  ]
    for conversion in conversions:
        for key in conversion[0]:
            latex = latex.replace(key, conversion[1])
    return latex


def reference_name(author, initials, year, ads_bibcode, ads_mirror):
    """
    Determine the letter after the date to cite as ie author2012a

    Parameters:
    -----------
    author : string
        The lower case surname of the author
    initials : string
        The author's initials in the form 'init1+init2'
    year : string
        The year the paper was published
    ads_bibcode : string
        the paper's ADS internal reference code

    Returns:
    --------
    string
        The complete paper name, i.e. author2012a
    """
    # Query ADS for all papers written by author in year, oldest first
    author_year_url = ('http://' + ads_mirror + '/cgi-bin/nph-abs_connect?'
    'db_key=AST''&db_key=PRE&qform=AST&arxiv_sel=astro-ph&arxiv_sel=cond-mat'
    '&arxiv_sel=cs&arxiv_sel=gr-qc&arxiv_sel=hep-ex&arxiv_sel=hep-lat'
    '&arxiv_sel=hep-ph&arxiv_sel=hep-th&arxiv_sel=math&arxiv_sel=math-ph'
    '&arxiv_sel=nlin&arxiv_sel=nucl-ex&arxiv_sel=nucl-th&arxiv_sel=physics'
    '&arxiv_sel=quant-ph&arxiv_sel=q-bio&sim_query=YES&ned_query=YES'
    '&adsobj_query=YES&aut_logic=OR&obj_logic=OR&author=%5E{0}%2C+{1}&object='
    '&start_mon=&start_year={2}&end_mon=&end_year={2}&ttl_logic=OR&title='
    '&txt_logic=OR&text=&nr_to_return=200&start_nr=1&jou_pick=ALL&ref_stems='
    '&data_and=ALL&group_and=ALL&start_entry_day=&start_entry_mon='
    '&start_entry_year=&end_entry_day=&end_entry_mon=&end_entry_year='
    '&min_score=&sort=ODATE&data_type=Custom&format=%25r&aut_syn=YES'
    '&ttl_syn=YES&txt_syn=YES&aut_wt=1.0&obj_wt=1.0&ttl_wt=0.3&txt_wt=3.0'
    '&aut_wgt=YES&obj_wgt=YES&ttl_wgt=YES&txt_wgt=YES&ttl_sco=YES&txt_sco=YES'
    '&version=1').format('+'.join(author.split()), initials, year)

    # Need this request to specifiy custom user agent
    url_req = req.Request(author_year_url,
    headers={'User-Agent': 'Bibtex retrieval script'})
    full_auth_year_page = req.urlopen(url_req).readlines()

    # Match bibcode to one of those returned - place in list determines letter
    # This could be changed to DOI - it affects conference proceedings and old
    # papers without a DOI
    publication_number = 0
    count = -1
    for line in range(5, len(full_auth_year_page)):
        if full_auth_year_page[line][:-2].decode('iso-8859-1') != '':
            count += 1
        if full_auth_year_page[line][:-2].decode('iso-8859-1') == ads_bibcode:
            publication_number = count

    paper_name = ''.join(author.lower().split()) + year
    if count > 0:
        paper_name += chr(ord('a') + publication_number)
    return paper_name


def write_new_entry(identifier, out_file, ads_mirror):
    """
    Write a BibTeX entry for identifier to the out_file

    Parameters:
    -----------
    identifier : 2 element tuple (identifier type, value)
        Identifier type can be {'doi', arxiv', 'abs'}
    out_file : string
        The file to write to, e.g. 'articles.bib'

    Returns:
    --------
    tuple, 3 elements
        (author : str, reference name : str, title of paper : str)
    """
    full_bibtex_page = req.urlopen(bibtex_url(identifier,
                                              ads_mirror)).readlines()

    bib = []
    for line in full_bibtex_page[5:-1]:
        bib.append(line.decode('iso-8859-1'))

    details = {}
    # Need to parse bibtex entry and make necessary changes
    for line in range(len(bib)):
        line_list = bib[line].split()
        if line_list[0] == 'author':
            details['author'] = re.search(r'(?<={{)'  # start at {{
                                          r'.*?'      # min num of anything
                                          r'(?=},)',  # end at },
                                          bib[line]).group()
            details['initials'] = re.search(r'(?<=}, )'       # start at '}, '
                                            r'.*?'            # min num of any
                                            r'(?=(}| and))',  # end at } or and
                                            bib[line]).group()
            if details['initials'][:4] == 'Jr.,':
                details['initials'] = details['initials'][4:]
            details['initials'] = '+'.join([i for i in details['initials']
                                            if i.isalpha()])
            details['author'] = latex_to_text(details['author'])
            #details['author'].replace('-', '')
        elif line_list[0] == 'year':
            details['year'] = line_list[2][:-1]
        elif line_list[0] == 'journal':
            line_list[2] = format_journal(' '.join(line_list[2:]))
            del line_list[3:]
        elif line_list[0] == 'adsnote':
            details['adsnote_line'] = line
        elif line_list[0] == 'adsurl':
            line_list[0] = 'url'
            details['ads_bibcode'] = os.path.split(line_list[2][1:-2])[-1]
            try:
                pos = details['ads_bibcode'].index('%26')
                # Replace doesn't work for some reason
                details['ads_bibcode'] = (details['ads_bibcode'][:pos] + '&' +
                                          details['ads_bibcode'][(pos + 3):])
            except ValueError:
                pass
            # Change link in URL to main ADS website
            line_list[2] = line_list[2].replace(ads_mirror,
                                                'adsabs.harvard.edu')
        #elif line_list[0] == 'doi':
        #    doi = line_list[2][1:-2]
        elif line_list[0] == 'title':
            details['title'] = latex_to_text(bib[line][14:-4])
        bib[line] = ' '.join(line_list) + '\n'

    del(bib[details['adsnote_line']])

    # Look up best name to use for reference (need to determine letter on end)
    try:
        #ref_name = reference_name(details['author'], details['initials'],
        #                          details['year'], details['ads_bibcode'])
        bib[0] = ''.join([bib[0][:bib[0].find('{') + 1].lower(),
                          details['ads_bibcode'], ',\n'         ])

        with open(out_file, 'a') as bib_file:
            for line in bib:
                bib_file.write(line)
            bib_file.write('\n')
        #return (details['author'], details['year'], ref_name, details['title'])
        return "{author} - {year} - {bibcode} - {title}".format(
                author=details['author'], year=details['year'],
                bibcode=details['ads_bibcode'], title=details['title'])
    except UnboundLocalError:  # Paper has no ADS bibcode
        raise LookupError


def main():
    """
    Parse command line arguments and run script stages
    """
    parser = argparse.ArgumentParser(description=("Process a directory of .pdf"
                                                  " files into a bibtex .bib"
                                                  " file"))
    parser.add_argument("directory", type=str,
                        help=("A directory of .pdf files to add to a .bib"
                              " file (default: .)"))
    parser.add_argument("bibtex_file", type=str, nargs='?',
                        default="articles.bib",
                        help=("The .bib file to append bibtex entries to,"
                              " the full path can be specified, if not the"
                              " file will be created in the pdf directory"
                              " (default: articles.bib)"                  ))
    args = parser.parse_args()

    # Format paths to args.directory and bib_file correctly
    if args.directory[-1] != '/':
        args.directory += '/'
    txt = args.directory + 'pdf.txt'
    path_head, path_tail = os.path.split(args.bibtex_file)
    if path_head is '':
        bib_file = args.directory + args.bibtex_file
    else:
        bib_file = args.bibtex_file

    # Parse pdfs and write to bibtex_file
    ads_mirror = 'esoads.eso.org'
    count = {'total': 0, 'already_included': 0, 'added': 0, 'failed': 0}
    for pdf in glob.glob(args.directory + '*.pdf'):
        count['total'] += 1
        # Skip if pdf is already included in bib_file
        if exists_in_bib(pdf=pdf, bib_file=bib_file) == True:
            print('*** Already in ' + bib_file + ':', pdf)
            count['already_included'] += 1
            continue
        # Extract identifiying information from the first page of the pdf
        subprocess.call(['pdftotext', '-l', '1', pdf, txt],
                        shell=False, stderr=subprocess.PIPE)
        # 2 element tuple doi, arxiv, abs
        identifier = extract_info(txt)
        os.remove(txt)
        try:
            if identifier is None:
                raise LookupError
            # Write bibtex for paper to bib_file
            new_name = write_new_entry(identifier=identifier,
                                         out_file=bib_file   )
            # Rename the pdf
            #new_name = args.directory + '{0} - {1} - {2}.pdf' \
            #            .format(paper_info[0],
            #               paper_info[1][len(''.join(paper_info[0].split())):],
            #                    paper_info[2])
            print(pdf + '\n', ' -->', new_name)
            count['added'] += 1
            os.rename(pdf, new_name)
        except (LookupError, urllib.error.HTTPError):
            print("*** Cannot process", pdf)
            count['failed'] += 1
        except urllib.error.URLError:
            print("*** ERROR: pdftobib requires an internet connection")
            sys.exit(None)

    print()
    # Print a summary of the operation
    print('Summary:')
    print(('Total PDFs: {0}\nAlready included in {bib}: {1}\n'
           'Added to {bib}: {2}\nFailed: {3}').format(count['total'],
                                                count['already_included'],
                                                      count['added'],
                                                      count['failed'],
                                                      bib=bib_file        ))


if __name__ == '__main__':
    main()
